# Substring with Concatenation of All Words

You are given a string, **s**, and a list of words, **words**, that are all of the same length. Find all starting indices of substring(s) in **s** that is a concatenation of each word in **words** exactly once and without any intervening characters.

For example,

> given:
> 
> **s**: `"barfoothefoobarman"`
> 
> **words**: `["foo", "bar"]`

You should return the indices: `[0,9]`.

(order does not matter).

## Solution Sketch

### C++
```C++
class Solution {
public:
    vector<int> findSubstring(string s, vector<string>& words) {

    }
};
```

### Java
```Java
public class Solution {
    public List<Integer> findSubstring(String s, String[] words) {

    }
}
```

### Python
```Python
class Solution(object):
    def findSubstring(self, s, words):
        """
        :type s: str
        :type words: List[str]
        :rtype: List[int]
        """
```

### C
```C
/**
 * Return an array of size *returnSize.
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* findSubstring(char* s, char** words, int wordsSize, int* returnSize) {

}
```

### C# 
```C#
public class Solution {
    public IList<int> FindSubstring(string s, string[] words) {

    }
}
```

### JavaScript
```JavaScript
/**
 * @param {string} s
 * @param {string[]} words
 * @return {number[]}
 */
var findSubstring = function(s, words) {

};
```

### Ruby
```Ruby
# @param {String} s
# @param {String[]} words
# @return {Integer[]}
def find_substring(s, words)

end
```
